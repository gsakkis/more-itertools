import sys
from enum import Enum
from typing import (
    Any,
    Callable,
    Generic,
    Iterable,
    Iterator,
    NoReturn,
    Optional,
    Tuple,
    TypeVar,
    Union,
    overload,
)

_T = TypeVar("_T")
_S = TypeVar("_S")
_N = TypeVar("_N", int, float)
_Predicate = Callable[[_T], bool]

class StatePolicy(Enum):
    SHARE: str = ...
    COPY: str = ...
    TRANSFER: str = ...

class UnusableIterator:
    def __iter__(self) -> NoReturn: ...
    def __next__(self) -> NoReturn: ...
    def __bool__(self) -> NoReturn: ...
    def __getattr__(self, attr: str) -> NoReturn: ...

class rich_iter(Iterator[_T]):
    state_policy: StatePolicy
    def __init__(
        self,
        iterable: Iterable[_T],
        state_policy: Union[StatePolicy, str] = ...,
    ) -> None: ...
    @classmethod
    def count(
        cls,
        start: _N = ...,
        step: _N = ...,
        *,
        state_policy: Union[StatePolicy, str] = ...
    ) -> rich_iter[_N]: ...
    @classmethod
    def repeat(
        cls,
        obj: _T,
        times: Optional[int] = ...,
        *,
        state_policy: Union[StatePolicy, str] = ...
    ) -> rich_iter[_T]: ...
    @classmethod
    def add_method(
        cls,
        wrapped: Callable,
        *,
        name: Optional[str] = ...,
        it_index: int = ...,
        preserve_cls: bool = ...
    ): ...
    def tee(self, n: int = ...) -> Tuple[rich_iter[_T], ...]: ...
    @overload
    def peek(self) -> _T: ...
    @overload
    def peek(self, default: _S) -> Union[_T, _S]: ...
    def __iter__(self) -> rich_iter[_T]: ...
    def __next__(self) -> _T: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> rich_iter[_T]: ...
    if sys.version_info >= (3, 8):
        @overload
        def accumulate(
            self, func: Optional[Callable[[_T, _T], _T]] = ...
        ) -> rich_iter[_T]: ...
        @overload
        def accumulate(
            self,
            func: Optional[Callable[[_S, _T], _S]],
            *,
            initial: Optional[_S]
        ) -> rich_iter[_S]: ...
    else:
        def accumulate(
            self, func: Optional[Callable[[_T, _T], _T]] = ...
        ) -> rich_iter[_T]: ...
    @property
    def chain(self) -> "rich_iter_chain[_T]": ...
    def compress(self, selectors: Iterable[Any]) -> rich_iter[_T]: ...
    def cycle(self) -> rich_iter[_T]: ...
    def dropwhile(self, __predicate: _Predicate[_T]) -> rich_iter[_T]: ...
    def enumerate(self, start: int = ...) -> rich_iter[_T]: ...
    def filter(self, predicate: Optional[_Predicate[_T]]) -> rich_iter[_T]: ...
    def filterfalse(
        self, __function: Optional[_Predicate[_T]]
    ) -> rich_iter[_T]: ...
    @overload
    def groupby(
        self, key: None = ...
    ) -> rich_iter[Tuple[_T, rich_iter[_T]]]: ...
    @overload
    def groupby(
        self, key: Callable[[_T], _S]
    ) -> rich_iter[Tuple[_S, rich_iter[_T]]]: ...
    @overload
    def islice(self, stop: Optional[int]) -> rich_iter[_T]: ...
    @overload
    def islice(
        self,
        start: Optional[int],
        stop: Optional[int],
        step: Optional[int] = ...,
    ) -> rich_iter[_T]: ...
    @overload
    def map(self, func: Callable[[_T], _S]) -> rich_iter[_S]: ...
    @overload
    def map(
        self, func: Callable[..., _S], *iterables: Iterable[Any]
    ) -> rich_iter[_S]: ...
    @overload
    def reduce(self, func: Callable[[_T, _S], _T], initial: _T) -> _T: ...
    @overload
    def reduce(self, func: Callable[[_T, _T], _T]) -> _T: ...
    if sys.version_info >= (3, 8):
        @overload
        def sum(self) -> Union[_T, int]: ...
        @overload
        def sum(self, start: _S) -> Union[_T, _S]: ...
    else:
        @overload
        def sum(self) -> Union[_T, int]: ...
        @overload
        def sum(self, __start: _S) -> Union[_T, _S]: ...
    def starmap(self, __func: Callable[..., _S]) -> rich_iter[_S]: ...
    def takewhile(self, __predicate: _Predicate[_T]) -> rich_iter[_T]: ...
    def zip(self, *iterables: Iterable[Any]) -> rich_iter[Tuple[Any, ...]]: ...
    def zip_longest(
        self, *iterables: Iterable[Any], fillvalue: Any = ...
    ) -> rich_iter[Tuple[Any, ...]]: ...
    def product(
        self, *iterables: Iterable[Any]
    ) -> rich_iter[Tuple[Any, ...]]: ...
    def permutations(
        self, r: Optional[int] = ...
    ) -> rich_iter[Tuple[_T, ...]]: ...
    def combinations(self, r: int) -> rich_iter[Tuple[_T, ...]]: ...
    def combinations_with_replacement(
        self, r: int
    ) -> rich_iter[Tuple[_T, ...]]: ...

class rich_iter_chain(Generic[_T]):
    def __init__(self, rich_iterator: rich_iter[_T]) -> None: ...
    def __call__(self, *iterables: Iterable[_T]) -> rich_iter[_T]: ...
    def from_iterable(self) -> rich_iter[_S]: ...
